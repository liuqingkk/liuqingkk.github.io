<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="跨域出现原因
浏览器限制跨域访问资源是一种安全策略，可以预防某些恶意行为。浏览器在每次发起请求时都会带上 cookie，试想下，如果没有这总安全策略，用户的数据就被泄露。跨域限制就是为了避免这种情况的发生。

解决方式

jsonp 之所以能够实现跨域资源的访问，是因为 script 标签不受浏览器" />
  

  
  
  
  
  
  
  <title>跨域详解及其常见的解决方式 | 宇情</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="跨域出现原因 浏览器限制跨域访问资源是一种安全策略，可以预防某些恶意行为。浏览器在每次发起请求时都会带上 cookie，试想下，如果没有这总安全策略，用户的数据就被泄露。跨域限制就是为了避免这种情况的发生。  解决方式  jsonp 之所以能够实现跨域资源的访问，是因为 script 标签不受浏览器同源策略的限制，使用时将 src 属性指定一个跨域 URL，服务器在收到请求后，将数据放到指定的 o">
<meta property="og:type" content="article">
<meta property="og:title" content="跨域详解及其常见的解决方式">
<meta property="og:url" content="http://yoursite.com/%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/index.html">
<meta property="og:site_name" content="宇情">
<meta property="og:description" content="跨域出现原因 浏览器限制跨域访问资源是一种安全策略，可以预防某些恶意行为。浏览器在每次发起请求时都会带上 cookie，试想下，如果没有这总安全策略，用户的数据就被泄露。跨域限制就是为了避免这种情况的发生。  解决方式  jsonp 之所以能够实现跨域资源的访问，是因为 script 标签不受浏览器同源策略的限制，使用时将 src 属性指定一个跨域 URL，服务器在收到请求后，将数据放到指定的 o">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-16T09:50:10.000Z">
<meta property="article:modified_time" content="2020-03-16T11:45:12.785Z">
<meta property="article:author" content="刘晴">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 4.2.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="宇情" rel="home">宇情</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">首页</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">目录</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-跨域详解及其常见的解决方式" class="post-跨域详解及其常见的解决方式 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      跨域详解及其常见的解决方式
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/" data-id="ck7ujdcat0006jstlawy45msx" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="跨域出现原因"><a href="#跨域出现原因" class="headerlink" title="跨域出现原因"></a>跨域出现原因</h3><blockquote>
<p>浏览器限制跨域访问资源是一种安全策略，可以预防某些恶意行为。浏览器在每次发起请求时都会带上 cookie，试想下，如果没有这总安全策略，用户的数据就被泄露。跨域限制就是为了避免这种情况的发生。</p>
</blockquote>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><blockquote>
<ol>
<li>jsonp 之所以能够实现跨域资源的访问，是因为 script 标签不受浏览器同源策略的限制，使用时将 src 属性指定一个跨域 URL，服务器在收到请求后，将数据放到指定的 onback 里传回来。<blockquote>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>
<span class="token comment">// 传参并指定回调执行函数为 onBack</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://www.....:8080/login?user=admin&amp;callback=onBack'</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 回调执行函数</span>
<span class="token keyword">function</span> <span class="token function">onBack</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote>
</li>
<li>CORS（cross-origin-resource-sharing）跨域资源共享，其思想是使用自定义的 HTTP 头部，让浏览器域服务器进行沟通，从而决定请求或响应是成功还是失败。服务器端一般在 Access-Control-Allow-Origin 中指定对应的域，当浏览器访问对应的资源。主要是后端在请求头里面设置安全域名</li>
<li>document.domain + iframe 跨域 此方案仅限主域相同，子域不同的跨域应用场景 父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">http://www.domain.com/a.html</a>) <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>iframe<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><a href="http://child.domain.com/b.html" target="_blank" rel="noopener">http://child.domain.com/b.html</a><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span> > <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><br>document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span> > <span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token string">'admin'</span><span class="token punctuation">;</span> > </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span> > </code></pre></div> 子窗口：(<a href="http://child.domain.com/b.html" target="_blank" rel="noopener">http://child.domain.com/b.html</a>) <div class="language-javascript extra-class"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span> > <span class="token comment">// 获取父窗口中变量</span> > <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'get js data from parent ---&gt; '</span> <span class="token operator">+</span> window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> > </code></pre></div></li>
<li>nginx 代理跨域</li>
<li>nodejs 中间件代理跨域</li>
</ol>
</blockquote>
<h3 id="三次握手-建立连接协议"><a href="#三次握手-建立连接协议" class="headerlink" title="三次握手 建立连接协议"></a>三次握手 建立连接协议</h3><blockquote>
<p>第一次 客户端发出请求, 服务器接收, 服务器就知道客户端通信是正常的</p>
</blockquote>
<blockquote>
<p>第二次服务器端发出请求 客户端知道其服务器端数据传输为正常（并且也知道自己的数据传输正常 因为可以确定第一次发的消息服务器已经接收到）</p>
</blockquote>
<blockquote>
<p>第三次客户端重新发送请求, 服务器端接收到客户端的请求从而判断自己的收发能力都是正常的, 因为第二次向服务器端发送的数据客户端已经准确收到, 这样经过三次握手之后客户端和服务器端都知道彼此数据传输正常, 从而建立通信。</p>
</blockquote>
<h3 id="连接终止协议（四次握手）"><a href="#连接终止协议（四次握手）" class="headerlink" title="连接终止协议（四次握手）"></a>连接终止协议（四次握手）</h3><blockquote>
<p>原理：由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ol>
<li>第一次挥手：主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。</li>
<li>第二次挥手：被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号， SYN 和 FIN 都有 seq 序号）。</li>
<li>第三次挥手：被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li>
<li>第四次挥手：主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li>
</ol>
</blockquote>
<h3 id="在浏览器中输入网址到看到网页内容经历了哪些过程"><a href="#在浏览器中输入网址到看到网页内容经历了哪些过程" class="headerlink" title="在浏览器中输入网址到看到网页内容经历了哪些过程"></a>在浏览器中输入网址到看到网页内容经历了哪些过程</h3><blockquote>
<ol>
<li>浏览器获取这个网址之后，会先去缓存中看看有没有要访问的资源，从浏览器缓存-系统缓存-路由缓存中查看，如果有就不再进行 hhtp 请求，直接从缓存中加载资源。否则进行步骤 2。（缓存就是把之前访问过的 web 资源，例如 css、js、图片等资源保存在本机的内存或磁盘中）</li>
<li>浏览器拿到域名自动去向 DNS(域名系统)服务器发起请求，查询用户输入的域名对应的 ip 地址 （域名的设定是为了方便人类记忆，而机器识别的是 ip 地址）</li>
<li>浏览器拿到 ip 地址后，通过 ip 地址和端口号和服务器建立 tcp 连接。（建立 tcp 连接需要经过三次“握手”，是可靠连接，能确认数据最终是否送达到目标）</li>
<li>三次“握手”建立连接成功之后，浏览器开始向服务器发起 http 请求，并通过 http 协议将请求信息包装成请求报文（包含请求行、请求头、空行、请求体），然后通过 socket 发送到服务器</li>
<li>当服务器接收到客户端浏览器发送过来的请求报文时候，按照 HTTP 协议将请求报文解析出来</li>
<li>然后服务器拿着请求报文中的请求信息（例如请求路径 url），做相应的业务逻辑处理操作</li>
<li>当业务逻辑处理操作完成之后，服务器将发送给浏览器的数据按照 http 协议包装成响应报文（响应行、响应头、空行、响应体</li>
<li>然后服务器将响应报文发送给浏览器</li>
<li>浏览器接收到响应报文后，按照 HTTP 协议将响应报文解析出来</li>
<li>浏览器拿到响应报文中响应体的数据开始渲染 html、css，执行 javaScript</li>
<li>如果在解析的过程（从上到下）中，发现有外链的标签（link、css、img）浏览器会自动对该标签指向的 路径地址 发起新的请求，同上。</li>
</ol>
</blockquote>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/">
    <time datetime="2020-03-16T09:50:10.000Z" class="entry-date">
        2020-03-16
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
    
        <span class="nav-next"><a href="/vue%E5%92%8Cjs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="next">vue和js常见问题 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/">跨域详解及其常见的解决方式</a>
          </li>
        
          <li>
            <a href="/vue%E5%92%8Cjs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">vue和js常见问题</a>
          </li>
        
          <li>
            <a href="/%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/">关于小程序</a>
          </li>
        
          <li>
            <a href="/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/">数组去重方法?</a>
          </li>
        
          <li>
            <a href="/cookie-%E5%92%8C-sessionStorage-%E4%BB%A5%E5%8F%8A-localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/">cookie 和 sessionStorage 以及 localStorage 的区别是什么?</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 刘晴
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>